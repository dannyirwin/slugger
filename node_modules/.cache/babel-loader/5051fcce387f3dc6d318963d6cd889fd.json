{"ast":null,"code":"import config from \"./config\";\nconst PI = Math.PI;\nconst TWOPI = 2 * Math.PI;\nconst HALFPI = PI / 2;\nexport default function runGame(canvas, gameSize = config.gameSize, upBtn, downBtn, leftBtn, rightBtn) {\n  const ctx = canvas.getContext(\"2d\");\n  const responsiveSize = config.responsiveSize;\n  const numOfCells = config.numOfCells;\n  const sideLength = responsiveSize ? findScreenSize() : config.gameSize;\n  const scale = sideLength / numOfCells;\n  const backgroundColor = config.backgroundColor;\n\n  function findScreenSize() {\n    const size = window.innerWidth < window.innerHeight ? window.innerWidth : window.innerHeight;\n    return size * 0.9;\n  }\n\n  function resizeCanvas() {\n    canvas.height = sideLength;\n    canvas.width = sideLength;\n  }\n\n  function drawBackground() {\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, sideLength, sideLength);\n    ctx.fillStyle = \"rgba(255,255,255, 0.2)\";\n\n    for (let i = 0; i < numOfCells; i += 2) {\n      for (let j = 0; j < numOfCells; j += 2) {\n        ctx.fillRect(i * scale, j * scale, scale, scale);\n        ctx.fillRect((i + 1) * scale, (j + 1) * scale, scale, scale);\n      }\n    }\n  }\n\n  function cellPosToCanvasPos(positionArray) {\n    const x = Math.floor(positionArray[0] * scale + scale * 0.5);\n    const y = Math.floor(positionArray[1] * scale + scale * 0.5);\n    return [x, y];\n  }\n\n  function createSlug(color = \"salmon\", x = Math.floor(numOfCells / 2), y = Math.floor(numOfCells / 2)) {\n    return {\n      color: color,\n      direction: \"north\",\n      bellyPositions: [],\n      isDigesting: false,\n      mouthOpen: false,\n      segmentPositions: [[x, y], [x, y + 1], [x, y + 2]],\n      update: function () {\n        this.checkCollision();\n        this.moveSlug();\n        this.handleDigestion();\n        this.drawSlug();\n        this.drawBelly();\n        this.drawHead();\n      },\n      drawSlug: function () {\n        const minWidth = scale * 0.2;\n        const maxWidth = scale * 0.8;\n        const widthInc = maxWidth - minWidth / this.segmentPositions.length * scale;\n        let width = maxWidth;\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = maxWidth;\n        ctx.lineCap = \"round\";\n        ctx.lineJoin = \"round\";\n        ctx.beginPath(); //ctx.moveTo(this.segmentPositions[0][0], this.segmentPositions[0][1]);\n\n        this.segmentPositions.forEach((segmentPosition, index) => {\n          const position = cellPosToCanvasPos(segmentPosition);\n          width -= widthInc;\n          ctx.lineWidth = width;\n          ctx.lineTo(position[0], position[1]);\n          ctx.stroke();\n          ctx.moveTo(position[0], position[1]);\n          console.log(ctx.lineWidth);\n        });\n      },\n      drawHead: function () {\n        const position = cellPosToCanvasPos(this.segmentPositions[0]);\n        const x = position[0];\n        const y = position[1];\n        const antennaLen = scale;\n        const angle = this.direction === \"south\" ? -2 : 2;\n        ctx.beginPath();\n        ctx.lineWidth = scale * 0.1;\n        let xTip = antennaLen * Math.cos(angle);\n        let yTip = antennaLen * Math.sin(angle);\n        ctx.moveTo(x + xTip, y - yTip);\n        ctx.lineTo(x, y);\n        ctx.lineTo(x - xTip, y - yTip);\n        ctx.stroke();\n        let headArcStart = 0;\n        let headArcEnd = TWOPI;\n        const mouthAngle = 0.5;\n        /*         if (this.mouthOpen) {\n          this.mouthOpen = false;\n          switch (this.direction) {\n            case \"north\":\n              headArcStart = -1 * HALFPI - mouthAngle;\n              headArcEnd = -1 * HALFPI + mouthAngle;\n            default:\n              break;\n            case \"south\":\n              break;\n            case \"east\":\n              break;\n            case \"west\":\n              break;\n          }\n        } */\n\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.arc(x, y, scale * 0.55, headArcStart, headArcEnd);\n        ctx.fill();\n      },\n      drawBelly: function () {\n        if (this.isDigesting) {\n          ctx.fillStyle = this.color;\n          this.bellyPositions.forEach(position => {\n            position = cellPosToCanvasPos(position);\n            ctx.beginPath();\n            ctx.arc(position[0], position[1], scale * 0.5, 0, TWOPI);\n            ctx.fill();\n          });\n        }\n      },\n      moveSlug: function () {\n        this.segmentPositions.pop();\n        this.segmentPositions.unshift(this.findNextPosition());\n      },\n      findNextPosition: function (direction = this.direction) {\n        const firstSegment = this.segmentPositions[0];\n        let newSegment = [];\n\n        switch (direction) {\n          case \"north\":\n            newSegment[0] = firstSegment[0];\n            newSegment[1] = firstSegment[1] - 1;\n            break;\n\n          case \"west\":\n            newSegment[0] = firstSegment[0] - 1;\n            newSegment[1] = firstSegment[1];\n            break;\n\n          case \"south\":\n            newSegment[0] = firstSegment[0];\n            newSegment[1] = firstSegment[1] + 1;\n            break;\n\n          case \"east\":\n            newSegment[0] = firstSegment[0] + 1;\n            newSegment[1] = firstSegment[1];\n            break;\n\n          default:\n            console.error(\"ERROR: expected 'north' 'south' 'east' or 'west' but got \" + direction);\n        }\n\n        return newSegment;\n      },\n      checkCollision: function () {\n        const nextPosition = this.findNextPosition();\n        const nextSegmentPositions = [...this.segmentPositions];\n        nextSegmentPositions.pop();\n        const collideWithSelf = nextSegmentPositions.some(position => position[0] === nextPosition[0] && position[1] === nextPosition[1]);\n        const collideWithEdge = nextPosition[0] < 0 || nextPosition[0] > numOfCells - 1 || nextPosition[1] < 0 || nextPosition[1] > numOfCells - 1;\n        const collideWithSnack = nextPosition[0] === snack.position[0] && nextPosition[1] === snack.position[1];\n\n        if (collideWithSelf || collideWithEdge) {\n          isPaused = true;\n          gameOver();\n        } else if (collideWithSnack) {\n          this.handleEatSnack();\n        }\n      },\n      handleEatSnack: function () {\n        this.bellyPositions.push(snack.position);\n        this.isDigesting = true;\n        this.mouthOpen = true;\n        snack.handleEaten();\n      },\n      handleMovementInput: function (direction) {\n        const nextPosition = this.findNextPosition(direction);\n        const canMoveThere = !this.segmentPositions.some(position => position[0] === nextPosition[0] && position[1] === nextPosition[1]);\n\n        if (canMoveThere) {\n          this.direction = direction;\n        }\n      },\n      handleDigestion: function () {\n        if (this.isDigesting) {\n          const tempPositions = [...this.bellyPositions];\n          tempPositions.forEach(position => {\n            const finalSegment = this.segmentPositions[this.segmentPositions.length - 1];\n\n            if (position[0] === finalSegment[0] && position[1] === finalSegment[1]) {\n              this.segmentPositions.push(position);\n              this.bellyPositions.shift();\n\n              if (this.bellyPositions.length === 0) {\n                this.isDigesting = false;\n              }\n            }\n          });\n        }\n      }\n    };\n  }\n\n  function createSnack(color = \"#66b8ff\") {\n    const newSnack = {\n      color: color,\n      position: [0, 0],\n      randomizePosition: function () {\n        const slugPositions = [slug.findNextPosition()].concat(slug.segmentPositions);\n        const randomX = Math.floor(Math.random() * numOfCells);\n        const randomY = Math.floor(Math.random() * numOfCells);\n\n        if (slugPositions.length - 2 === numOfCells ** 2) {\n          gameOver(\"You WIN!\");\n        } else if (slugPositions.some(position => position[0] === randomX && position[1] === randomY)) {\n          this.randomizePosition();\n        } else {\n          this.position = [randomX, randomY];\n        }\n      },\n      drawSnack: function () {\n        const position = cellPosToCanvasPos(this.position);\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.arc(position[0], position[1], scale * 0.3, 0, TWOPI);\n        ctx.fill();\n      },\n      handleEaten: function () {\n        snack = createSnack();\n      }\n    };\n    newSnack.randomizePosition();\n    return newSnack;\n  }\n\n  function gameOver(message = \"Game Over\") {\n    isPaused = true;\n    slug = createSlug();\n    snack = createSnack();\n    drawBackground();\n    alert(message);\n  }\n\n  let isPaused = true;\n  const fps = config.fps;\n  const fpsInterval = 1000 / fps;\n  let now, then, delta;\n\n  function startGame(fps) {\n    then = window.performance.now();\n    requestAnimationFrame(update);\n  }\n\n  function update() {\n    now = window.performance.now();\n    delta = now - then;\n\n    if (delta > fpsInterval) {\n      then = now - delta % fpsInterval;\n      drawBackground();\n      slug.update();\n      snack.drawSnack();\n    }\n\n    !isPaused && requestAnimationFrame(update);\n  }\n\n  function init() {\n    resizeCanvas();\n    drawBackground();\n    startGame();\n  }\n\n  let slug = createSlug();\n  let snack = createSnack();\n  window.addEventListener(\"load\", init);\n  document.addEventListener(\"keydown\", event => {\n    const key = event.key.toLocaleLowerCase();\n\n    switch (key) {\n      case \" \":\n        isPaused && update();\n        break;\n\n      case \"p\":\n        isPaused = !isPaused;\n        !isPaused && requestAnimationFrame(update);\n        break;\n\n      case \"w\":\n      case \"arrowup\":\n        slug.handleMovementInput(\"north\");\n        break;\n\n      case \"s\":\n      case \"arrowdown\":\n        slug.handleMovementInput(\"south\");\n        break;\n\n      case \"a\":\n      case \"arrowleft\":\n        slug.handleMovementInput(\"west\");\n        break;\n\n      case \"d\":\n      case \"arrowright\":\n        slug.handleMovementInput(\"east\");\n        break;\n\n      default:\n        break;\n    }\n  });\n\n  if (upBtn && downBtn && leftBtn && rightBtn) {\n    upBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"north\");\n    });\n    downBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"south\");\n    });\n    leftBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"west\");\n    });\n    rightBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"east\");\n    });\n  }\n}","map":{"version":3,"sources":["/Users/dirwin/Development/slugger/src/slugger.js"],"names":["config","PI","Math","TWOPI","HALFPI","runGame","canvas","gameSize","upBtn","downBtn","leftBtn","rightBtn","ctx","getContext","responsiveSize","numOfCells","sideLength","findScreenSize","scale","backgroundColor","size","window","innerWidth","innerHeight","resizeCanvas","height","width","drawBackground","fillStyle","fillRect","i","j","cellPosToCanvasPos","positionArray","x","floor","y","createSlug","color","direction","bellyPositions","isDigesting","mouthOpen","segmentPositions","update","checkCollision","moveSlug","handleDigestion","drawSlug","drawBelly","drawHead","minWidth","maxWidth","widthInc","length","strokeStyle","lineWidth","lineCap","lineJoin","beginPath","forEach","segmentPosition","index","position","lineTo","stroke","moveTo","console","log","antennaLen","angle","xTip","cos","yTip","sin","headArcStart","headArcEnd","mouthAngle","arc","fill","pop","unshift","findNextPosition","firstSegment","newSegment","error","nextPosition","nextSegmentPositions","collideWithSelf","some","collideWithEdge","collideWithSnack","snack","isPaused","gameOver","handleEatSnack","push","handleEaten","handleMovementInput","canMoveThere","tempPositions","finalSegment","shift","createSnack","newSnack","randomizePosition","slugPositions","slug","concat","randomX","random","randomY","drawSnack","message","alert","fps","fpsInterval","now","then","delta","startGame","performance","requestAnimationFrame","init","addEventListener","document","event","key","toLocaleLowerCase"],"mappings":"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","sourcesContent":["import config from \"./config\";\n\nconst PI = Math.PI;\nconst TWOPI = 2 * Math.PI;\nconst HALFPI = PI / 2;\n\nexport default function runGame(\n  canvas,\n  gameSize = config.gameSize,\n  upBtn,\n  downBtn,\n  leftBtn,\n  rightBtn\n) {\n  const ctx = canvas.getContext(\"2d\");\n  const responsiveSize = config.responsiveSize;\n  const numOfCells = config.numOfCells;\n  const sideLength = responsiveSize ? findScreenSize() : config.gameSize;\n  const scale = sideLength / numOfCells;\n  const backgroundColor = config.backgroundColor;\n\n  function findScreenSize() {\n    const size =\n      window.innerWidth < window.innerHeight\n        ? window.innerWidth\n        : window.innerHeight;\n    return size * 0.9;\n  }\n\n  function resizeCanvas() {\n    canvas.height = sideLength;\n    canvas.width = sideLength;\n  }\n  function drawBackground() {\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, sideLength, sideLength);\n    ctx.fillStyle = \"rgba(255,255,255, 0.2)\";\n\n    for (let i = 0; i < numOfCells; i += 2) {\n      for (let j = 0; j < numOfCells; j += 2) {\n        ctx.fillRect(i * scale, j * scale, scale, scale);\n        ctx.fillRect((i + 1) * scale, (j + 1) * scale, scale, scale);\n      }\n    }\n  }\n  function cellPosToCanvasPos(positionArray) {\n    const x = Math.floor(positionArray[0] * scale + scale * 0.5);\n    const y = Math.floor(positionArray[1] * scale + scale * 0.5);\n    return [x, y];\n  }\n  function createSlug(\n    color = \"salmon\",\n    x = Math.floor(numOfCells / 2),\n    y = Math.floor(numOfCells / 2)\n  ) {\n    return {\n      color: color,\n      direction: \"north\",\n      bellyPositions: [],\n      isDigesting: false,\n      mouthOpen: false,\n      segmentPositions: [\n        [x, y],\n        [x, y + 1],\n        [x, y + 2]\n      ],\n      update: function () {\n        this.checkCollision();\n        this.moveSlug();\n        this.handleDigestion();\n        this.drawSlug();\n        this.drawBelly();\n        this.drawHead();\n      },\n      drawSlug: function () {\n        const minWidth = scale * 0.2;\n        const maxWidth = scale * 0.8;\n        const widthInc =\n          maxWidth - (minWidth / this.segmentPositions.length) * scale;\n        let width = maxWidth;\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = maxWidth;\n        ctx.lineCap = \"round\";\n        ctx.lineJoin = \"round\";\n        ctx.beginPath();\n\n        //ctx.moveTo(this.segmentPositions[0][0], this.segmentPositions[0][1]);\n        this.segmentPositions.forEach((segmentPosition, index) => {\n          const position = cellPosToCanvasPos(segmentPosition);\n          width -= widthInc;\n          ctx.lineWidth = width;\n          ctx.lineTo(position[0], position[1]);\n          ctx.stroke();\n          ctx.moveTo(position[0], position[1]);\n\n          console.log(ctx.lineWidth);\n        });\n      },\n      drawHead: function () {\n        const position = cellPosToCanvasPos(this.segmentPositions[0]);\n        const x = position[0];\n        const y = position[1];\n        const antennaLen = scale;\n\n        const angle = this.direction === \"south\" ? -2 : 2;\n\n        ctx.beginPath();\n        ctx.lineWidth = scale * 0.1;\n\n        let xTip = antennaLen * Math.cos(angle);\n        let yTip = antennaLen * Math.sin(angle);\n\n        ctx.moveTo(x + xTip, y - yTip);\n        ctx.lineTo(x, y);\n        ctx.lineTo(x - xTip, y - yTip);\n        ctx.stroke();\n\n        let headArcStart = 0;\n        let headArcEnd = TWOPI;\n\n        const mouthAngle = 0.5;\n\n        /*         if (this.mouthOpen) {\n          this.mouthOpen = false;\n          switch (this.direction) {\n            case \"north\":\n              headArcStart = -1 * HALFPI - mouthAngle;\n              headArcEnd = -1 * HALFPI + mouthAngle;\n            default:\n              break;\n            case \"south\":\n              break;\n            case \"east\":\n              break;\n            case \"west\":\n              break;\n          }\n        } */\n\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.arc(x, y, scale * 0.55, headArcStart, headArcEnd);\n        ctx.fill();\n      },\n      drawBelly: function () {\n        if (this.isDigesting) {\n          ctx.fillStyle = this.color;\n          this.bellyPositions.forEach(position => {\n            position = cellPosToCanvasPos(position);\n            ctx.beginPath();\n            ctx.arc(position[0], position[1], scale * 0.5, 0, TWOPI);\n            ctx.fill();\n          });\n        }\n      },\n      moveSlug: function () {\n        this.segmentPositions.pop();\n        this.segmentPositions.unshift(this.findNextPosition());\n      },\n      findNextPosition: function (direction = this.direction) {\n        const firstSegment = this.segmentPositions[0];\n        let newSegment = [];\n        switch (direction) {\n          case \"north\":\n            newSegment[0] = firstSegment[0];\n            newSegment[1] = firstSegment[1] - 1;\n            break;\n          case \"west\":\n            newSegment[0] = firstSegment[0] - 1;\n            newSegment[1] = firstSegment[1];\n            break;\n          case \"south\":\n            newSegment[0] = firstSegment[0];\n            newSegment[1] = firstSegment[1] + 1;\n            break;\n          case \"east\":\n            newSegment[0] = firstSegment[0] + 1;\n            newSegment[1] = firstSegment[1];\n            break;\n          default:\n            console.error(\n              \"ERROR: expected 'north' 'south' 'east' or 'west' but got \" +\n                direction\n            );\n        }\n        return newSegment;\n      },\n      checkCollision: function () {\n        const nextPosition = this.findNextPosition();\n        const nextSegmentPositions = [...this.segmentPositions];\n        nextSegmentPositions.pop();\n        const collideWithSelf = nextSegmentPositions.some(\n          position =>\n            position[0] === nextPosition[0] && position[1] === nextPosition[1]\n        );\n        const collideWithEdge =\n          nextPosition[0] < 0 ||\n          nextPosition[0] > numOfCells - 1 ||\n          nextPosition[1] < 0 ||\n          nextPosition[1] > numOfCells - 1;\n        const collideWithSnack =\n          nextPosition[0] === snack.position[0] &&\n          nextPosition[1] === snack.position[1];\n\n        if (collideWithSelf || collideWithEdge) {\n          isPaused = true;\n          gameOver();\n        } else if (collideWithSnack) {\n          this.handleEatSnack();\n        }\n      },\n      handleEatSnack: function () {\n        this.bellyPositions.push(snack.position);\n        this.isDigesting = true;\n        this.mouthOpen = true;\n        snack.handleEaten();\n      },\n      handleMovementInput: function (direction) {\n        const nextPosition = this.findNextPosition(direction);\n        const canMoveThere = !this.segmentPositions.some(\n          position =>\n            position[0] === nextPosition[0] && position[1] === nextPosition[1]\n        );\n        if (canMoveThere) {\n          this.direction = direction;\n        }\n      },\n      handleDigestion: function () {\n        if (this.isDigesting) {\n          const tempPositions = [...this.bellyPositions];\n          tempPositions.forEach(position => {\n            const finalSegment =\n              this.segmentPositions[this.segmentPositions.length - 1];\n            if (\n              position[0] === finalSegment[0] &&\n              position[1] === finalSegment[1]\n            ) {\n              this.segmentPositions.push(position);\n              this.bellyPositions.shift();\n              if (this.bellyPositions.length === 0) {\n                this.isDigesting = false;\n              }\n            }\n          });\n        }\n      }\n    };\n  }\n  function createSnack(color = \"#66b8ff\") {\n    const newSnack = {\n      color: color,\n      position: [0, 0],\n      randomizePosition: function () {\n        const slugPositions = [slug.findNextPosition()].concat(\n          slug.segmentPositions\n        );\n        const randomX = Math.floor(Math.random() * numOfCells);\n        const randomY = Math.floor(Math.random() * numOfCells);\n        if (slugPositions.length - 2 === numOfCells ** 2) {\n          gameOver(\"You WIN!\");\n        } else if (\n          slugPositions.some(\n            position => position[0] === randomX && position[1] === randomY\n          )\n        ) {\n          this.randomizePosition();\n        } else {\n          this.position = [randomX, randomY];\n        }\n      },\n      drawSnack: function () {\n        const position = cellPosToCanvasPos(this.position);\n\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.arc(position[0], position[1], scale * 0.3, 0, TWOPI);\n        ctx.fill();\n      },\n      handleEaten: function () {\n        snack = createSnack();\n      }\n    };\n    newSnack.randomizePosition();\n    return newSnack;\n  }\n  function gameOver(message = \"Game Over\") {\n    isPaused = true;\n    slug = createSlug();\n    snack = createSnack();\n    drawBackground();\n    alert(message);\n  }\n\n  let isPaused = true;\n  const fps = config.fps;\n  const fpsInterval = 1000 / fps;\n  let now, then, delta;\n\n  function startGame(fps) {\n    then = window.performance.now();\n    requestAnimationFrame(update);\n  }\n\n  function update() {\n    now = window.performance.now();\n    delta = now - then;\n\n    if (delta > fpsInterval) {\n      then = now - (delta % fpsInterval);\n      drawBackground();\n      slug.update();\n      snack.drawSnack();\n    }\n    !isPaused && requestAnimationFrame(update);\n  }\n\n  function init() {\n    resizeCanvas();\n    drawBackground();\n    startGame();\n  }\n\n  let slug = createSlug();\n  let snack = createSnack();\n\n  window.addEventListener(\"load\", init);\n\n  document.addEventListener(\"keydown\", event => {\n    const key = event.key.toLocaleLowerCase();\n    switch (key) {\n      case \" \":\n        isPaused && update();\n        break;\n      case \"p\":\n        isPaused = !isPaused;\n        !isPaused && requestAnimationFrame(update);\n        break;\n      case \"w\":\n      case \"arrowup\":\n        slug.handleMovementInput(\"north\");\n        break;\n      case \"s\":\n      case \"arrowdown\":\n        slug.handleMovementInput(\"south\");\n        break;\n      case \"a\":\n      case \"arrowleft\":\n        slug.handleMovementInput(\"west\");\n        break;\n      case \"d\":\n      case \"arrowright\":\n        slug.handleMovementInput(\"east\");\n        break;\n      default:\n        break;\n    }\n  });\n\n  if (upBtn && downBtn && leftBtn && rightBtn) {\n    upBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"north\");\n    });\n\n    downBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"south\");\n    });\n\n    leftBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"west\");\n    });\n\n    rightBtn.addEventListener(\"click\", () => {\n      slug.handleMovementInput(\"east\");\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}